<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>五年后的自己</title>
      <link href="/2019/07/26/%E4%BA%94%E5%B9%B4%E5%90%8E%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
      <url>/2019/07/26/%E4%BA%94%E5%B9%B4%E5%90%8E%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="五年后的自己"><a href="#五年后的自己" class="headerlink" title="五年后的自己"></a>五年后的自己</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪吃球</title>
      <link href="/2019/07/25/%E8%B4%AA%E5%90%83%E7%90%83/"/>
      <url>/2019/07/25/%E8%B4%AA%E5%90%83%E7%90%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-实战要求"><a href="#1-实战要求" class="headerlink" title="1.实战要求"></a>1.实战要求</h1><blockquote><p>1.学会使用unity一些基本的操作。<br>2.学会一些基本的脚本代码编写。<br>3.完整代码：<a href="https://github.com/DedicationTechology/unity_GreedyBall" target="_blank" rel="noopener">https://github.com/DedicationTechology/unity_GreedyBall</a><br>4.注意相关的脚本要拖动到对应的物体的属性栏中</p></blockquote><h1 id="2-项目需求"><a href="#2-项目需求" class="headerlink" title="2.项目需求"></a>2.项目需求</h1><blockquote><p>开发一款可以使用键盘方向键控制小球来吃小方块并且记分的小游戏。</p></blockquote><h1 id="3-项目开发流程"><a href="#3-项目开发流程" class="headerlink" title="3.项目开发流程"></a>3.项目开发流程</h1><h2 id="3-1基本场景搭建"><a href="#3-1基本场景搭建" class="headerlink" title="3.1基本场景搭建"></a>3.1基本场景搭建</h2><blockquote><p>1.创建一个地面Plane<br>2.创建四周的围墙来限制小球的运动范围(创建多个cube,注意不要加刚体属性，防止围墙被撞飞)<br>3.创建一个小球Sphere(设定刚体属性：Add Component–&gt;pysical–&gt;Rigidbody)<br>4.创建食物(用cube来代替)<br>5.创建分数显示面板和游戏结束显示面板(Create–&gt;UI–&gt;Test)(创建两个面板)</p></blockquote><h2 id="3-2围墙操作"><a href="#3-2围墙操作" class="headerlink" title="3.2围墙操作"></a>3.2围墙操作</h2><blockquote><p>1.使用ctrl+d表示复制并创建物体，对需要多次使用的物体，创建一个prefab文件夹，将该物体拖至该文件夹下充当模板，需要多个物体时只需从该模板下拖拽即可，同时当模板的相关属性改变时，其实物的相关属性也都改变<br>2.按住ctrl键拖拽可以等距离移动物体<br>3.当需要另外两个方向的墙体时，可以使用重置物体，点击属性面板(Inspector)中Transform右上角的设置按钮下的reset，然后修改物体的比例scale来改变方向</p></blockquote><h2 id="3-3小球操作"><a href="#3-3小球操作" class="headerlink" title="3.3小球操作"></a>3.3小球操作</h2><h3 id="3-3-1通过键盘控制小球的移动"><a href="#3-3-1通过键盘控制小球的移动" class="headerlink" title="3.3.1通过键盘控制小球的移动"></a>3.3.1通过键盘控制小球的移动</h3><blockquote><p>1.在工程面板下创建一个script文件夹用来放置工程的脚本文件<br>2.创建一个脚本sphere</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;public class sphere : MonoBehaviour {    private Rigidbody rgd;//定义一个刚体组件    public int  speed = 3;//设置一个速度用来控制键盘移动小球的速度    // Use this for initialization    void Start () {//该部分表示只执行一次        rgd = GetComponent<Rigidbody>();//得到场景中的刚体组件并将值传递给rgd    }    // Update is called once per frame    void Update () {//该部分表示可以持续执行        float h = Input.GetAxis("Horizontal");//表示得到水平轴        float v = Input.GetAxis("Vertical");//表示达到竖直轴        rgd.AddForce(new Vector3(h, 0, v)*speed);//通知键盘来控制刚体不同方向上的变化    }}</code></pre><h3 id="3-3-2给小球创建一个触发器-注意与碰撞器的区别"><a href="#3-3-2给小球创建一个触发器-注意与碰撞器的区别" class="headerlink" title="3.3.2给小球创建一个触发器(注意与碰撞器的区别)"></a>3.3.2给小球创建一个触发器(注意与碰撞器的区别)</h3><h4 id="3-3-2-1说明"><a href="#3-3-2-1说明" class="headerlink" title="3.3.2.1说明"></a>3.3.2.1说明</h4><blockquote><p>碰撞器表示拥有碰撞器的物体不能穿过被碰撞的物体，而触发器表示拥有触发器的物体可以穿过其他物体(前提是其他物体的Inspector属性面板中的box collider中的is trigger必须勾选上)</p></blockquote><h4 id="3-3-2-2创建脚本"><a href="#3-3-2-2创建脚本" class="headerlink" title="3.3.2.2创建脚本"></a>3.3.2.2创建脚本</h4><blockquote><p>在script文件夹下创建一个脚本chufa，用来实现小球的触发操作</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;public class chufa : MonoBehaviour {    // Use this for initialization    void Start () {    }    // Update is called once per frame    void Update () {    }    //碰撞检测    //private void OnCollisionEnter(Collision collision)//定义碰撞器的标准格式    //{    //    if (collision .collider.tag == "pickup")//判断被碰撞物体的标签是否是pickup，防止碰撞到其他物体会执行下面的代码    //        Destroy(collision.collider.gameObject);//碰撞事件发生后，毁掉被碰撞的物体，表现在游戏中为被碰撞物体消失    //}    //触发检测：使用前要将触发器的box collider设置为is trigger    private void OnTriggerEnter(Collider other)//定义触发器的标准格式    {        if (other.tag == "pickup") {            Destroy(other.gameObject);        }    }}</code></pre><h2 id="3-4食物操作"><a href="#3-4食物操作" class="headerlink" title="3.4食物操作"></a>3.4食物操作</h2><blockquote><p>让小球实现旋转来表示食物<br>新建一个脚本cube</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;public class cude : MonoBehaviour {    // Use this for initialization    void Start () {    }    // Update is called once per frame    void Update () {        transform.Rotate(new Vector3(0, 1, 0));//物体向y轴方向旋转，每次旋转一度，update下物体一秒大概执行60次，transform表示当前物体    }}</code></pre><h2 id="3-5显示面板操作"><a href="#3-5显示面板操作" class="headerlink" title="3.5显示面板操作"></a>3.5显示面板操作</h2><blockquote><p>在chufa脚本中添加一些代码<br>在显示的属性面板中，在rect transform属性的左上角按住alt键选择显示在屏幕上的位置</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;//使用test组件时必须引入的命名空间public class chufa : MonoBehaviour {    private int score = 0;//设定初始分数为0    //说明何时创建一个组件类型的物体，何时创建一个物体类型,当需要操作某一物体组件下的属性时可以直接创建该物体的组件，当需要操作整个物体的显示等相关操作时需要创建一个物体    public Text text;//创建一个Test类型的物体text，需要在属性面板中选择需要插入的物体    public GameObject wintext;//创建一个物体wintext，需要在属性面板中选择需要插入的物体    // Use this for initialization    void Start () {    }    // Update is called once per frame    void Update () {    }    //碰撞检测    //private void OnCollisionEnter(Collision collision)//定义碰撞器的标准格式    //{    //    if (collision .collider.tag == "pickup")//判断被碰撞物体的标签是否是pickup，防止碰撞到其他物体会执行下面的代码    //        Destroy(collision.collider.gameObject);//碰撞事件发生后，毁掉被碰撞的物体，表现在游戏中为被碰撞物体消失    //}    //触发检测：使用前要将触发器的box collider设置为is trigger    private void OnTriggerEnter(Collider other)//定义触发器的标准格式    {        if (other.tag == "pickup") {            score++;//触发到一个物体分数加一            text.text = score.ToString();//将分数转化为string类型传输到text属性值中            if (score == 4)//判断当分数达到一定值时执行以下代码            {                wintext.SetActive(true);//显示整个组件，之前默认不显示该组件            }            Destroy(other.gameObject);            //注意区分碰撞器和触发器相关代码书写的差异        }    }}</code></pre><h2 id="3-6相机跟随物体移动"><a href="#3-6相机跟随物体移动" class="headerlink" title="3.6相机跟随物体移动"></a>3.6相机跟随物体移动</h2><blockquote><p>创建一个脚本follow</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;public class follow : MonoBehaviour {    public Transform MySphere;//设定一个Transform组件来得到物体的位置，MySphere需要在属性面板中指定物体    private Vector3 offset;//设定一个向量，用来存储x,y,z的位置    // Use this for initialization    void Start () {         offset= transform.position - MySphere.position;//transform表示当前物体的位置，在这里表示相机的位置，这里通过计算相机和物体位置的偏移量来确定相机与物体的位置联系    }    // Update is called once per frame    void Update () {        transform.position = offset + MySphere.position;//表示实施更新物体的位置而保证相机和物体位置的偏移量从而达到控制相机随物体运动的效果    }}</code></pre><h1 id="4上传游戏"><a href="#4上传游戏" class="headerlink" title="4上传游戏"></a>4上传游戏</h1><blockquote><p>点击untiy中file目录下的build setting选择build，然后选择需要保存的位置，会产生一个数据文件夹和一个.exe的应用程序，这两个文件缺一不可，数据文件夹中包括游戏需要的一些数据，点击.exe文件就可以开始游戏。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统学习</title>
      <link href="/2019/07/25/linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/25/linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-推荐学习网站"><a href="#1-推荐学习网站" class="headerlink" title="1.推荐学习网站"></a>1.推荐学习网站</h1><blockquote><p><a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">https://www.linuxprobe.com/</a></p></blockquote><h1 id="2-安装虚拟机及红帽操作系统"><a href="#2-安装虚拟机及红帽操作系统" class="headerlink" title="2.安装虚拟机及红帽操作系统"></a>2.安装虚拟机及红帽操作系统</h1><blockquote><p>1.虚拟机安装地址：<a href="https://pan.baidu.com/share/init?surl=dF9YCfB" target="_blank" rel="noopener">https://pan.baidu.com/share/init?surl=dF9YCfB</a><br>百度网盘密码为：sm7s<br>2.红帽系统安装地址：<a href="https://pan.baidu.com/s/1dEWdcch" target="_blank" rel="noopener">https://pan.baidu.com/s/1dEWdcch</a><br>百度网盘密码为：j94c<br>3.使用虚拟机：<br>(1)创建虚拟机–&gt;典型–&gt;稍后安装操作系统–&gt;linux redhat 7–&gt;设置位置和虚拟机名字–&gt;默认设置–&gt;完成–&gt;内存2GB(根据电脑内存设置，一般设置为电脑内存的一半，但当电脑内存大于4个G的时候，通常都设置为2GB–&gt;<br><img src="https://img-blog.csdnimg.cn/20190722211812684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX1NvZnRFbmdpbmVlcg==,size_16,color_FFFFFF,t_70" alt>说明：处理器的核心数量根据电脑的实际数量来设置(查看电脑处理器核心数量的方法：右击电脑选择设备管理器，选择处理器，一般显示几个就表明电脑的处理器的核心数量时几个)–&gt;新CD/DVD(使用ISO镜像文件，选择下载好的镜像文件)–&gt;网路适配器选择仅主机模式<br>说明：桥接模式：相当于在物理主机与虚拟机网卡之间架设了一座桥梁，从而可以通过物理主机的网卡访问外网。<br>NAT模式：让VM虚拟机的网络服务发挥路由器的作用，使得通过虚拟机软件模拟的主机可以通过物理主机访问外网，在真机中NAT虚拟机网卡对应的物理网卡是VMnet8。<br>仅主机模式：仅让虚拟机内的主机与物理主机通信，不能访问外网，在真机中仅主机模式模拟网卡对应的物理网卡是VMnet1。<br>–&gt;把USB控制器、声卡、打印机设备等不需要的设备统统移除掉<br>(2)安装红帽系统<br>–&gt;使用方向键选择第一个选项安装操作系统–&gt;选择语言为英文(美国)–&gt;单击SOFTWARE SELECTION选项，选中Server with GUI单选按钮，然后单击左上角的Done按钮即可–&gt;单击NETWORK &amp; HOSTNAME选项后，将Hostname字段设置为linuxprobe.com，然后单击左上角的Done按钮–&gt;返回到安装主界面，单击INSTALLATION DESTINATION选项来选择安装媒介并设置分区。此时不需要进行任何修改，单击左上角的Done按钮即可–&gt;单击Begin Installation按钮后即可看到安装进度–&gt;选择ROOT PASSWORD设置root管理员的密码–&gt;设置账号及密码–&gt;单击Reboot–&gt;单击LICENSE INFORMATION选项接受即可–&gt;<br><img src="https://img-blog.csdnimg.cn/20190722214606719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX1NvZnRFbmdpbmVlcg==,size_16,color_FFFFFF,t_70" alt>–&gt;<img src="https://img-blog.csdnimg.cn/20190722214620972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX1NvZnRFbmdpbmVlcg==,size_16,color_FFFFFF,t_70" alt></p></blockquote><h1 id="3-linux命令"><a href="#3-linux命令" class="headerlink" title="3.linux命令"></a>3.linux命令</h1><h2 id="3-1常用系统工作命令"><a href="#3-1常用系统工作命令" class="headerlink" title="3.1常用系统工作命令"></a>3.1常用系统工作命令</h2>]]></content>
      
      
      <categories>
          
          <category> 系统开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>穿越火线</title>
      <link href="/2019/07/25/%E7%A9%BF%E8%B6%8A%E7%81%AB%E7%BA%BF/"/>
      <url>/2019/07/25/%E7%A9%BF%E8%B6%8A%E7%81%AB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-导入所需的资源"><a href="#1-导入所需的资源" class="headerlink" title="1.导入所需的资源"></a>1.导入所需的资源</h1><blockquote><p>链接：<a href="https://pan.baidu.com/s/1kLnu28aPiZ7ak6j4rADqsw" target="_blank" rel="noopener">https://pan.baidu.com/s/1kLnu28aPiZ7ak6j4rADqsw</a>  提取码：m71u</p></blockquote><h1 id="2-项目开发"><a href="#2-项目开发" class="headerlink" title="2.项目开发"></a>2.项目开发</h1><h2 id="2-1标签的封装"><a href="#2-1标签的封装" class="headerlink" title="2.1标签的封装"></a>2.1标签的封装</h2><blockquote><p>创建一个名为Tags的脚本，将项目中所有将要使用的标签以const常量的方式进行分装。</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;public class Tags{    public const string player = "Player";//代表玩家    public const string gameController = "GameController";//代表游戏控制器    public const string enemy = "Enemy";//代表敌人    public const string fader = "Fader";//代表淡入淡出的画布    public const string mainCamera = "MainCamera";//代表主摄像机}</code></pre><h2 id="2-2实现屏幕淡入淡出的效果"><a href="#2-2实现屏幕淡入淡出的效果" class="headerlink" title="2.2实现屏幕淡入淡出的效果"></a>2.2实现屏幕淡入淡出的效果</h2><blockquote><p>1.在场景面板中创建一个空物体，命名为FadeInOut，加入组件GUI Texture，color设置为黑色，Texture设置为swatch_black_dff(在导入的资源中搜索)<br>2.为物体FadeInOut创建一个脚本FadeInOut用来实现屏幕的渐隐渐现</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;//SceneManager使用的命名空间public class FadeInOut : MonoBehaviour{    public float fadeSpeed = 1.5f;//设置渐隐渐现的速度    private bool sceneStarting = true;//设置场景开始，当场景开始时实现渐隐渐现的效果    private GUITexture tex;//设置一个GUITexture类型的组件名为tex    private void Start()    {        tex = this.GetComponent<GUITexture>();//给组件进行赋值        tex.pixelInset = new Rect(0, 0, Screen.width, Screen.height);//给组件初始化，位置为0，0,大小和屏幕一致    }    private void Update()    {        if (sceneStarting)        {            StartScene();//实现场景的渐现        }    }    private void FadeToClear()//实现渐现    {        tex.color = Color.Lerp(tex.color, Color.clear, fadeSpeed * Time.deltaTime);//fadeSpeed * Time.deltaTime表示速度    }    private void FadeToBlack()//实现渐隐    {        tex.color = Color.Lerp(tex.color, Color.black, fadeSpeed * Time.deltaTime);//tex.color表示当前的颜色，Color.black表示渐变后的颜色    }    private void StartScene()//渐现开始    {        FadeToClear();//场景开始实现渐现效果        if (tex.color.a <= 0.05f)//判断是否变为透明        {            tex.color = Color.clear;//将当前的颜色变为彻底透明            tex.enabled = false;//禁用GUI组件            sceneStarting = true;//将标识位设置为false        }    }    public void EndScene()//渐隐开始    {        tex.enabled = true;        FadeToBlack();        if (tex.color.a >= 0.95f)        {            SceneManager.LoadScene("Demo");//进行场景跳转到当前场景，进行重复加载        }    }}</code></pre><h2 id="2-3按键输入封装"><a href="#2-3按键输入封装" class="headerlink" title="2.3按键输入封装"></a>2.3按键输入封装</h2><blockquote><p>在场景面板中创建一个空物体，命名为GameController，将其Tag设置为GameController，同时设置脚本fps_Input</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;public class fps_Input : MonoBehaviour {    public class fps_InputAxis//自定义轴辅助类,存储自定义轴的信息    {        public KeyCode positive;//定义一个正向按键        public KeyCode negative;//定义一个负向按键    }    public Dictionary<string, KeyCode> buttons = new Dictionary<string, KeyCode>();//定义一个集合    public Dictionary<string, fps_InputAxis> axis = new Dictionary<string, fps_InputAxis>();//定义一个自定义轴集合    public List<string> unityAxis = new List<string>();//定义一个unity内部轴的集合    private void Start()    {        SetupDefault();    }    private void SetupDefault(string type = "")//设置默认的按键，type中的内容表示你要设置什么类型的东西，是按钮类型的、自定义轴还是uinty默认自带的轴    {        if(type == ""||type == "buttons")        {            if (buttons.Count == 0)//说明按钮没有进行过初始化            {                AddButton("Fire", KeyCode.Mouse0);//鼠标左键设置为开火键                AddButton("Reload", KeyCode.R);                AddButton("Jump", KeyCode.Space);                AddButton("Crouch", KeyCode.C);//蹲下按键                AddButton("Sprint", KeyCode.LeftShift);//加速按键            }        }        if (type == "" || type == "Axis")//初始化自定义轴        {            if (axis.Count == 0)            {                AddAxis("Horizontal", KeyCode.W, KeyCode.S);                AddAxis("Vertical", KeyCode.A, KeyCode.D);            }        }        if (type == "" || type == "UnityAxis")//初始化unity自定义的轴        {            if (unityAxis.Count == 0)            {                AddUnityAxis("Mouse X");                AddUnityAxis("Mouse Y");                AddUnityAxis("Horizontal");                AddUnityAxis("Vertical");            }        }    }    public void AddButton(string n,KeyCode k)//添加按钮的方法，两个参数表示按钮的名称和键位    {        if (buttons.ContainsKey(n))//判断按钮按键集合中是否包含该按钮            buttons[n] = k;//包含则加入键位        else            buttons.Add(n, k);//不包含则加入这个按钮和键位    }    private void AddAxis(string n,KeyCode pk,KeyCode nk)//添加自定义轴的方法，三个参数代表自定义轴的名称，正方向和负方向    {        if (axis.ContainsKey(n))        {            axis[n] = new fps_InputAxis() { positive = pk, negative = nk };        }        else        {            axis.Add(n, new fps_InputAxis() { positive = pk, negative = nk });        }    }    private void AddUnityAxis(string n)//添加unity自定义轴的方法    {        if (!unityAxis.Contains(n))        {            unityAxis.Add(n);        }    }    //外界获取调用的方法    public bool GetButton(string button)    {        if (buttons.ContainsKey(button))        {            return Input.GetKey(buttons[button]);//外界获取按钮的方法，只要按键没有被抬起就一直调用        }        return false;    }    public bool GetButtonDown(string button)    {        if (buttons.ContainsKey(button))        {            return Input.GetKeyDown(buttons[button]);//外界获取按钮按下的方法        }        return false;    }    public float GetAxis(string axis)//轴返回的值在-1到1之间，外界获取自定义轴的方法    {        if (this.unityAxis.Contains(axis))        {            return Input.GetAxis(axis);        }        else            return 0;    }    public float GetAxisRaw(string axis)//这里只返回三个值，-1，0，1    {        if (this.axis.ContainsKey(axis))//判断自定义轴是否包含这个轴        {            float val = 0;            if (Input.GetKey(this.axis[axis].positive))                return 1;//按下正向键返回1            if (Input.GetKey(this.axis[axis].negative))                return -1;            return val;        }        else if (unityAxis.Contains(axis))//如果自定义的轴不包含这个轴，就去unity自定义的轴去找        {            return Input.GetAxisRaw(axis);        }        else//都没有找到该轴        {            return 0;        }    }}</code></pre><h2 id="2-4用户输入的参数封装及赋值"><a href="#2-4用户输入的参数封装及赋值" class="headerlink" title="2.4用户输入的参数封装及赋值"></a>2.4用户输入的参数封装及赋值</h2><blockquote><p>1.创建一个空物体，作为我们的主角，重命名为FP_Player，将其位置设置为X：16.44，Z：-45.65，加入一个组件character controller(角色控制器)，将参数Center中的Y改为1，Radius改为0.4，后期所有的主角行为都通过角色控制器来操作。<br>2.书写一个脚本表示用户的输入状态，命名为fps_PlayerParameter，将脚本拖动到FP_Player中</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;[RequireComponent(typeof(CharacterController))]public class fps_PlayerParameter : MonoBehaviour{    [HideInInspector]//以下操作是通过用户的输入来操作，不需要显示在用户面板中，因此就隐藏属性    public Vector2 inputSmoothLook;//定义一个二维向量表示鼠标的输入    [HideInInspector]    public Vector2 inputMoveVector;//定义一个二维向量表示按键的输入    [HideInInspector]    public bool inputCrouch;//是否下蹲    [HideInInspector]    public bool inputJump;//是否跳跃    [HideInInspector]    public bool inputSprint;//是否冲刺    [HideInInspector]    public bool inputFire;//是否开火    [HideInInspector]    public bool inputReload;//是否装弹}</code></pre><blockquote><p>3.创建一个脚本，为上述定义的变量进行赋值，命名为fps_FPInput，拖动到FP_Player中</p></blockquote><pre class=" language-cs"><code class="language-cs">using System.Collections;using System.Collections.Generic;using UnityEngine;public class fps_FPInput : MonoBehaviour{    public bool LockCursor//由于是第一人称视角，不需要显示光标，锁定光标     {        get { return Cursor.lockState == CursorLockMode.Locked ? true : false; }//锁定返回true,反则返回false        set        {            Cursor.visible = value;//设定一个鼠标可见的变量            Cursor.lockState = value ? CursorLockMode.Locked : CursorLockMode.None;        }    }    private fps_PlayerParameter parameter;//给脚本的参数进行赋值    private fps_Input input;    void Start()    {        LockCursor = true;        parameter = this.GetComponent<fps_PlayerParameter>();//赋值parameter，通过该脚本所在物体中找到组件fps_PlayerParameter        input = GameObject.FindGameObjectWithTag(Tags.gameController).GetComponent<fps_Input>();//赋值input，通过游戏物体的标签区寻找组件fps_Input    }    private void Update()    {        InitialInput();    }    private void InitialInput()//对变量进行赋值    {        parameter.inputMoveVector = new Vector2(input.GetAxis("Horizontal"), input.GetAxis("Vertical"));        parameter.inputSmoothLook = new Vector2(input.GetAxisRaw("Mouse X"), input.GetAxisRaw("Mouse Y"));//通过鼠标控制相机进行旋转来达到视觉旋转的特效        parameter.inputCrouch = input.GetButton("Crouch");        parameter.inputJump = input.GetButton("Jump");        parameter.inputFire = input.GetButton("Fire");        parameter.inputSprint = input.GetButton("Sprint");        parameter.inputReload = input.GetButton("Reload");    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
